name: Secrets Deployment

on:
  #schedule:
    #- cron: '*/5 * * * *'  # Every 5 minutes
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (show what would be done without making changes)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      repository_filter:
        description: 'Repository filter (all/public/private/specific)'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'public'
          - 'private'
          - 'specific'
      specific_repos:
        description: 'Comma-separated list of specific repos (only if "specific" is selected)'
        required: false
        default: ''
        type: string
      secrets_to_create:
        description: 'Secrets to create (comma-separated)'
        required: true
        default: 'GCP_CREDENTIALS,AWS_ROLE_ARN,AWS_REGION,AZURE_CREDENTIALS'
        type: string

permissions:
  contents: read
  actions: read

env:
  GITHUB_USERNAME: sansritiishwar

jobs:
  prepare:
    name: Prepare Repository List
    runs-on: ubuntu-latest
    outputs:
      repositories: ${{ steps.get-repos.outputs.repositories }}
      total_count: ${{ steps.get-repos.outputs.total_count }}
      batch_matrix: ${{ steps.get-repos.outputs.batch_matrix }}
    steps:
    - name: Get Repository List
      id: get-repos
      uses: actions/github-script@v7
      env:
        REPOSITORY_FILTER: ${{ inputs.repository_filter }}
        SPECIFIC_REPOS: ${{ inputs.specific_repos }}
      with:
        github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        script: |
          const username = process.env.GITHUB_USERNAME;
          const filter = process.env.REPOSITORY_FILTER || 'all';
          const specificRepos = process.env.SPECIFIC_REPOS || '';
          
          console.log(`Fetching repositories for user: ${username}`);
          console.log(`Filter: ${filter}`);
          
          let repositories = [];
          
          if (filter === 'specific' && specificRepos) {
            // Handle specific repositories
            const repoNames = specificRepos.split(',').map(r => r.trim());
            for (const repoName of repoNames) {
              try {
                const { data: repo } = await github.rest.repos.get({
                  owner: username,
                  repo: repoName
                });
                repositories.push({
                  name: repo.name,
                  full_name: repo.full_name,
                  private: repo.private,
                  archived: repo.archived,
                  disabled: repo.disabled
                });
              } catch (error) {
                console.log(`Repository ${repoName} not found or not accessible`);
              }
            }
                  } else {
          // Get all repositories with pagination (including private repos)
          const iterator = github.paginate.iterator(github.rest.repos.listForAuthenticatedUser, {
            per_page: 100,
            sort: 'updated',
            direction: 'desc',
            visibility: 'all'  // Include both public and private repositories
          });
            
            for await (const { data: repos } of iterator) {
              for (const repo of repos) {
                // Skip archived and disabled repositories
                if (repo.archived || repo.disabled) {
                  console.log(`Skipping ${repo.name} (archived or disabled)`);
                  continue;
                }
                
                // Apply filter
                if (filter === 'public' && repo.private) continue;
                if (filter === 'private' && !repo.private) continue;
                
                repositories.push({
                  name: repo.name,
                  full_name: repo.full_name,
                  private: repo.private,
                  archived: repo.archived,
                  disabled: repo.disabled
                });
              }
            }
          }
          
          console.log(`Found ${repositories.length} repositories`);
          console.log('Repositories:', repositories.map(r => r.name).join(', '));
          
          // Calculate batch matrix
          const batchSize = 10;
          const totalBatches = Math.ceil(repositories.length / batchSize);
          const batchMatrix = Array.from({length: totalBatches}, (_, i) => i);
          
          console.log(`Will process in ${totalBatches} batches of ${batchSize} repositories each`);
          
          core.setOutput('repositories', JSON.stringify(repositories));
          core.setOutput('total_count', repositories.length.toString());
          core.setOutput('batch_matrix', JSON.stringify(batchMatrix));

  deploy-secrets:
    name: Deploy Secrets
    runs-on: ubuntu-latest
    needs: prepare
    if: fromJSON(needs.prepare.outputs.total_count) > 0
    strategy:
      matrix:
        batch: ${{ fromJSON(needs.prepare.outputs.batch_matrix) }}
      max-parallel: 3
      fail-fast: false
    steps:
    - name: Checkout (for local npm install)
      uses: actions/checkout@v4
    
    - name: Install tweetsodium locally
      run: npm install tweetsodium
    
    - name: Process Repository Batch ${{ matrix.batch }}
      uses: actions/github-script@v7
      env:
        BATCH_INDEX: ${{ matrix.batch }}
        REPOSITORIES_JSON: ${{ needs.prepare.outputs.repositories }}
        DRY_RUN: ${{ inputs.dry_run }}
        EVENT_NAME: ${{ github.event_name }}
        SECRETS_TO_CREATE: ${{ inputs.secrets_to_create }}
        GCP_CREDENTIALS: ${{ secrets.GCP_CREDENTIALS }}
        AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
        AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
        TERRAFORM_API_TOKEN: ${{ secrets.TERRAFORM_API_TOKEN }}
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
        NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        GITHUB_USERNAME: ${{ env.GITHUB_USERNAME }}
      with:
        github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        script: |
          const sodium = require('tweetsodium');
          const repositories = JSON.parse(process.env.REPOSITORIES_JSON);
          const batchSize = 10;
          const batchIndex = parseInt(process.env.BATCH_INDEX);
          const isDryRun = process.env.DRY_RUN === 'true' || process.env.EVENT_NAME === 'schedule';
          const secretsToCreate = (process.env.SECRETS_TO_CREATE || 'GCP_CREDENTIALS,AWS_ROLE_ARN,AWS_REGION,AZURE_CREDENTIALS').split(',').map(s => s.trim());
          
          const startIndex = batchIndex * batchSize;
          const endIndex = Math.min(startIndex + batchSize, repositories.length);
          const batchRepos = repositories.slice(startIndex, endIndex);
          
          console.log(`Processing batch ${batchIndex + 1}: repositories ${startIndex + 1} to ${endIndex}`);
          console.log(`Repositories in this batch: ${batchRepos.map(r => r.name).join(', ')}`);
          
          // Secrets values mapping
          const secretValues = {
            'GCP_CREDENTIALS': process.env.GCP_CREDENTIALS,
            'AWS_ROLE_ARN': process.env.AWS_ROLE_ARN,
            'AWS_REGION': process.env.AWS_REGION || 'us-east-1',
            'AZURE_CREDENTIALS': process.env.AZURE_CREDENTIALS,
            'TERRAFORM_API_TOKEN': process.env.TERRAFORM_API_TOKEN,
            'CLOUDFLARE_API_TOKEN': process.env.CLOUDFLARE_API_TOKEN,
            'DOCKER_HUB_TOKEN': process.env.DOCKER_HUB_TOKEN,
            'NPM_TOKEN': process.env.NPM_TOKEN
          };
          
          // Function to encrypt secret value
          async function encryptSecret(publicKey, value) {
            const key = Buffer.from(publicKey, 'base64');
            const encrypted = sodium.seal(Buffer.from(value), key);
            return Buffer.from(encrypted).toString('base64');
          }
          
          // Process each repository in this batch
          for (const repo of batchRepos) {
            try {
              console.log(`\nüîÑ Processing repository: ${repo.name}`);
              
              if (isDryRun) {
                console.log(`  ‚ÑπÔ∏è  [DRY RUN] Would create secrets: ${secretsToCreate.join(', ')}`);
                continue;
              }
              
              // Get repository public key for secret encryption
              const { data: publicKey } = await github.rest.actions.getRepoPublicKey({
                owner: process.env.GITHUB_USERNAME,
                repo: repo.name
              });
              
              let successCount = 0;
              let skipCount = 0;
              let errorCount = 0;
              
              for (const secretName of secretsToCreate) {
                try {
                  const secretValue = secretValues[secretName];
                  
                  if (!secretValue) {
                    console.log(`  ‚ö†Ô∏è  Skipping ${secretName}: Value not available or empty`);
                    skipCount++;
                    continue;
                  }
                  
                  // Encrypt the secret value
                  const encryptedValue = await encryptSecret(publicKey.key, secretValue);
                  
                  // Create or update the secret
                  await github.rest.actions.createOrUpdateRepoSecret({
                    owner: process.env.GITHUB_USERNAME,
                    repo: repo.name,
                    secret_name: secretName,
                    encrypted_value: encryptedValue,
                    key_id: publicKey.key_id
                  });
                  
                  console.log(`  ‚úÖ Created/Updated secret: ${secretName}`);
                  successCount++;
                  
                  // Small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 100));
                  
                } catch (secretError) {
                  console.log(`  ‚ùå Failed to create secret ${secretName}: ${secretError.message}`);
                  errorCount++;
                }
              }
              
              console.log(`  üìä Repository ${repo.name} summary: ${successCount} success, ${skipCount} skipped, ${errorCount} errors`);
              
            } catch (repoError) {
              console.log(`  ‚ùå Failed to process repository ${repo.name}: ${repoError.message}`);
            }
          }

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [prepare, deploy-secrets]
    if: always()
    steps:
    - name: Generate Summary
      uses: actions/github-script@v7
      env:
        TOTAL_REPOS: ${{ needs.prepare.outputs.total_count }}
        DRY_RUN: ${{ inputs.dry_run }}
        EVENT_NAME: ${{ github.event_name }}
        REPOSITORY_FILTER: ${{ inputs.repository_filter }}
        SECRETS_TO_CREATE: ${{ inputs.secrets_to_create }}
      with:
        script: |
          const totalRepos = process.env.TOTAL_REPOS;
          const isDryRun = process.env.DRY_RUN === 'true' || process.env.EVENT_NAME === 'schedule';
          const filter = process.env.REPOSITORY_FILTER || 'all';
          const secretsToCreate = process.env.SECRETS_TO_CREATE || 'GCP_CREDENTIALS,AWS_ROLE_ARN,AWS_REGION,AZURE_CREDENTIALS';
          const triggerType = process.env.EVENT_NAME === 'schedule' ? 'Scheduled (Every 5min)' : 'Manual';
          
          const summary = `
          ## üöÄ Mass Secrets Deployment ${isDryRun ? '(DRY RUN)' : ''} Complete
          
          ### Configuration
          - **User Profile**: ${process.env.GITHUB_USERNAME}
          - **Trigger**: ${triggerType}
          - **Repository Filter**: ${filter}
          - **Total Repositories**: ${totalRepos}
          - **Secrets**: ${secretsToCreate}
          - **Mode**: ${isDryRun ? 'üîç Dry Run (No Changes Made)' : '‚úÖ Live Deployment'}
          
          ### Results
          ${isDryRun ? 
            '- This was a dry run - no actual changes were made to any repositories\n- Review the logs above to see what would have been created' :
            '- Secrets have been deployed to all accessible repositories\n- Check individual repository settings to verify secrets were created\n- Some secrets may have been skipped if values were not available'
          }
          
          ### Next Steps
          ${isDryRun ? 
            '1. Review the dry run results above\n2. Set the required secret values in this repository\n3. Re-run with dry_run set to "false" to deploy secrets' :
            '1. Verify secrets in individual repositories\n2. Test workflows that depend on these secrets\n3. Update any missing secret values if needed'
          }
          
          ### Security Note
          - All secrets are encrypted before storage using GitHub's public key encryption
          - Only repository administrators can view secret names (user profile repositories)
          - Secret values are never visible in the GitHub interface
          `;
          
          core.summary.addRaw(summary);
          console.log(summary);

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [prepare, deploy-secrets, summary]
    if: always()
    steps:
    - name: Final Status
      run: |
        echo "üéâ Mass secrets deployment workflow completed"
        echo "üìã Check the summary above for detailed results"
        echo "üîê All secrets are encrypted and secure"